<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Screen & Webcam Recorder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .status-dot {
            height: 10px;
            width: 10px;
            border-radius: 50%;
            display: inline-block;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        #webcamContainer {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            border: 3px solid #4f46e5;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            overflow: hidden;
            cursor: move;
            resize: both;
            z-index: 10;
            display: none; /* Hidden by default */
        }
        #webcamContainer.circle {
            border-radius: 50%;
        }
        #webcamContainer.square {
            border-radius: 0.75rem; /* rounded-lg */
        }
        #webcamPreview {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror mode */
        }
        /* Hide resize handle from appearing on video element */
        video::-webkit-resizer {
          display: none;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex items-center justify-center min-h-screen">

    <div class="w-full max-w-4xl mx-auto p-6 md:p-8">
        <div class="bg-gray-800 border border-gray-700 rounded-2xl shadow-2xl shadow-indigo-500/10 overflow-hidden">
            <div class="p-6 md:p-8">
                <div class="flex flex-col md:flex-row items-center justify-between gap-4">
                    <div>
                        <h1 class="text-2xl md:text-3xl font-bold text-white">Screen & Webcam Recorder by Sheikh Jalal</h1>
                        <p class="text-gray-400 mt-1">Record your screen, with an optional webcam overlay.</p>
                    </div>
                    <div id="status" class="flex items-center gap-2 px-4 py-2 bg-gray-700 rounded-full text-sm">
                        <span id="status-dot" class="status-dot bg-gray-500"></span>
                        <span id="status-text">Idle</span>
                    </div>
                </div>
            </div>

            <!-- Main Video Area -->
            <div id="videoContainer" class="relative bg-black aspect-video w-full">
                <video id="videoPreview" class="w-full h-full object-contain" controls muted></video>
                <!-- Webcam Preview Container -->
                <div id="webcamContainer" class="circle">
                    <video id="webcamPreview" autoplay muted></video>
                </div>
            </div>

            <!-- Controls -->
            <div class="p-6 md:p-8 bg-gray-800/50 border-t border-gray-700">
                <!-- Main Action Buttons -->
                <div class="flex flex-col sm:flex-row items-center justify-center gap-4">
                    <button id="startBtn" class="w-full sm:w-auto flex items-center justify-center gap-2 bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-6 rounded-lg transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-indigo-500/50">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m22 8-6 4 6 4V8Z"/><rect width="14" height="12" x="2" y="6" rx="2" ry="2"/></svg>
                        Start Recording
                    </button>
                    <button id="stopBtn" class="w-full sm:w-auto flex items-center justify-center gap-2 bg-red-600 hover:bg-red-700 text-white font-semibold py-3 px-6 rounded-lg transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-red-500/50" disabled>
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"/></svg>
                        Stop Recording
                    </button>
                </div>

                <!-- Webcam Controls -->
                <div class="mt-6 pt-6 border-t border-gray-700 flex flex-col sm:flex-row items-center justify-center gap-6">
                     <div class="flex items-center gap-3">
                        <input type="checkbox" id="webcamToggle" class="h-5 w-5 rounded bg-gray-700 border-gray-600 text-indigo-600 focus:ring-indigo-500">
                        <label for="webcamToggle" class="text-gray-300">Include Webcam</label>
                    </div>
                    <button id="shapeToggleBtn" class="flex items-center gap-2 text-gray-300 hover:text-white disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.8c.2.5.2 1.1 0 1.6l-2.5 4.4c-.4.7-1.2 1.1-2 1.1H7.5c-.8 0-1.6-.4-2-1.1L3 14.4c-.2-.5-.2-1.1 0-1.6l2.5-4.4c.4-.7 1.2-1.1 2-1.1h7c.8 0 1.6.4 2 1.1l2.5 4.4Z"/></svg>
                        Toggle Shape
                    </button>
                </div>

                <!-- Download Container -->
                <div id="downloadContainer" class="mt-6 text-center" style="display: none;">
                     <a id="downloadLink" class="w-full sm:w-auto inline-flex items-center justify-center gap-2 bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-6 rounded-lg transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-green-500/50">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></svg>
                        Download Recording
                    </a>
                </div>
            </div>
        </div>
        <p class="text-center text-gray-500 text-xs mt-6">
            Your privacy is respected. All recordings are processed locally in your browser.
        </p>
    </div>

    <script>
        // DOM Element References
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const videoPreview = document.getElementById('videoPreview');
        const downloadLink = document.getElementById('downloadLink');
        const downloadContainer = document.getElementById('downloadContainer');
        const statusText = document.getElementById('status-text');
        const statusDot = document.getElementById('status-dot');
        const webcamToggle = document.getElementById('webcamToggle');
        const shapeToggleBtn = document.getElementById('shapeToggleBtn');
        const webcamContainer = document.getElementById('webcamContainer');
        const webcamPreview = document.getElementById('webcamPreview');
        const videoContainer = document.getElementById('videoContainer');

        // State variables
        let mediaRecorder;
        let recordedChunks = [];
        let screenStream;
        let webcamStream;
        let combinedStream;
        let canvas;
        let ctx;
        let animationFrameId;

        // --- Webcam Drag & Resize Logic ---
        let isDragging = false;
        let offsetX, offsetY;

        webcamContainer.addEventListener('mousedown', (e) => {
            // Prevent dragging from starting on the resize handles
            if (e.target !== webcamContainer) return;
            isDragging = true;
            offsetX = e.clientX - webcamContainer.offsetLeft;
            offsetY = e.clientY - webcamContainer.offsetTop;
            webcamContainer.style.cursor = 'grabbing';
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            let newX = e.clientX - offsetX;
            let newY = e.clientY - offsetY;
            
            // Constrain within the video container bounds
            const parentRect = videoContainer.getBoundingClientRect();
            const elRect = webcamContainer.getBoundingClientRect();

            newX = Math.max(0, Math.min(newX, parentRect.width - elRect.width));
            newY = Math.max(0, Math.min(newY, parentRect.height - elRect.height));

            webcamContainer.style.left = `${newX}px`;
            webcamContainer.style.top = `${newY}px`;
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            webcamContainer.style.cursor = 'move';
        });

        // --- Event Listeners ---
        webcamToggle.addEventListener('change', () => {
            shapeToggleBtn.disabled = !webcamToggle.checked;
            if (webcamToggle.checked) {
                webcamContainer.style.display = 'block';
            } else {
                webcamContainer.style.display = 'none';
            }
        });

        shapeToggleBtn.addEventListener('click', () => {
            webcamContainer.classList.toggle('circle');
            webcamContainer.classList.toggle('square');
        });

        startBtn.addEventListener('click', async () => {
            recordedChunks = [];
            downloadLink.href = '';
            downloadContainer.style.display = 'none';
            videoPreview.src = '';

            try {
                // Get Screen Stream
                screenStream = await navigator.mediaDevices.getDisplayMedia({
                    video: { cursor: "always" },
                    audio: { echoCancellation: true, noiseSuppression: true }
                });

                // Get Webcam Stream if enabled
                if (webcamToggle.checked) {
                    webcamStream = await navigator.mediaDevices.getUserMedia({
                        video: { width: 320, height: 320 },
                        audio: false
                    });
                    webcamPreview.srcObject = webcamStream;
                }
                
                // Set up canvas for combining streams
                canvas = document.createElement('canvas');
                const screenVideoTrack = screenStream.getVideoTracks()[0];
                const { width, height } = screenVideoTrack.getSettings();
                canvas.width = width;
                canvas.height = height;
                ctx = canvas.getContext('2d');

                // Create a temporary video element to play the screen stream for drawing
                const tempScreenVideo = document.createElement('video');
                tempScreenVideo.srcObject = screenStream;
                tempScreenVideo.muted = true;
                tempScreenVideo.play();
                
                // Start the drawing loop
                drawStreamsToCanvas(tempScreenVideo);

                // Create combined stream from canvas
                combinedStream = canvas.captureStream(30); // 30 FPS

                // Add audio track from screen stream to the combined stream
                const audioTracks = screenStream.getAudioTracks();
                if (audioTracks.length > 0) {
                    combinedStream.addTrack(audioTracks[0]);
                }
                
                videoPreview.srcObject = combinedStream;
                videoPreview.play();

                mediaRecorder = new MediaRecorder(combinedStream, { mimeType: 'video/webm; codecs=vp9' });
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) recordedChunks.push(event.data);
                };
                mediaRecorder.onstop = handleStop;
                mediaRecorder.start();
                updateUIForRecording(true);

            } catch (err) {
                console.error("Error starting recording:", err);
                alert("Could not start recording. Please grant all required permissions.");
                updateUIForRecording(false);
                stopAllStreams();
            }
        });

        stopBtn.addEventListener('click', () => {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }
            stopAllStreams();
            updateUIForRecording(false);
        });

        // --- Helper Functions ---
        function drawStreamsToCanvas(screenVideo) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Draw screen
            ctx.drawImage(screenVideo, 0, 0, canvas.width, canvas.height);

            // Draw webcam if enabled
            if (webcamToggle.checked && webcamStream) {
                const containerRect = videoContainer.getBoundingClientRect();
                const webcamRect = webcamContainer.getBoundingClientRect();
                
                // Calculate position and size relative to the canvas
                const webcamX = (webcamRect.left - containerRect.left) * (canvas.width / containerRect.width);
                const webcamY = (webcamRect.top - containerRect.top) * (canvas.height / containerRect.height);
                const webcamWidth = webcamRect.width * (canvas.width / containerRect.width);
                const webcamHeight = webcamRect.height * (canvas.height / containerRect.height);

                ctx.save();
                // Create clipping path for shape
                if (webcamContainer.classList.contains('circle')) {
                    ctx.beginPath();
                    ctx.arc(webcamX + webcamWidth / 2, webcamY + webcamHeight / 2, webcamWidth / 2, 0, Math.PI * 2);
                    ctx.clip();
                } else { // square
                     ctx.beginPath();
                     ctx.rect(webcamX, webcamY, webcamWidth, webcamHeight);
                     ctx.clip();
                }
                
                // Draw webcam video, mirrored
                ctx.translate(webcamX + webcamWidth, webcamY);
                ctx.scale(-1, 1);
                ctx.drawImage(webcamPreview, 0, 0, webcamWidth, webcamHeight);
                ctx.restore();
            }
            
            animationFrameId = requestAnimationFrame(() => drawStreamsToCanvas(screenVideo));
        }

        function stopAllStreams() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            [screenStream, webcamStream, combinedStream].forEach(stream => {
                stream?.getTracks().forEach(track => track.stop());
            });
            videoPreview.srcObject = null;
            webcamPreview.srcObject = null;
        }

        function handleStop() {
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            
            videoPreview.srcObject = null;
            videoPreview.src = url;
            videoPreview.load();
            videoPreview.play();
            videoPreview.muted = false;

            downloadLink.href = url;
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            downloadLink.download = `recording-${timestamp}.webm`;
            downloadContainer.style.display = 'block';
        }

        function updateUIForRecording(isRecording) {
            startBtn.disabled = isRecording;
            stopBtn.disabled = !isRecording;
            webcamToggle.disabled = isRecording;
            shapeToggleBtn.disabled = isRecording || !webcamToggle.checked;

            if (isRecording) {
                statusText.textContent = 'Recording...';
                statusDot.classList.remove('bg-gray-500');
                statusDot.classList.add('bg-red-500');
                webcamContainer.style.resize = 'none'; // Disable resize during recording
            } else {
                statusText.textContent = 'Idle';
                statusDot.classList.remove('bg-red-500');
                statusDot.classList.add('bg-gray-500');
                webcamContainer.style.resize = 'both';
            }
        }
    </script>
</body>
</html>
